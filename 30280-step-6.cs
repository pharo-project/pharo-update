'From Pharo3.0 of 18 March 2013 [Latest update: #30272] on 16 July 2013 at 11:27:42 am'!!TClass methodsFor: '*Ring-Core-Kernel' stamp: 'SebastianTleye 7/16/2013 11:18'!asFullRingDefinition	"A behavior is converted to a ring class including its variables, methods, direct superclass, direct subclasses and the package in which is loaded.	Active methods are generated and each knows its package as well.	Note that for its direct superclass and subclasses no full definitions are requested. If you need to traverse hierarchies use #asRingDefinitionWithMethods:withSuperclasses:withSubclasses:withPackages:"		| rgClass rgSuper rgSub rgMethod packageKeys |	rgClass:= self asRingDefinition.	rgClass package: (RGContainer packageOfClass: rgClass).		self superclass notNil 		ifTrue: [ 			rgSuper := self superclass asRingDefinition.			rgClass superclass: rgSuper ]		ifFalse: [  			self isTrait ifTrue: [ 				rgSuper := Trait asRingDefinition.				rgClass superclass: rgSuper. ]			].	self subclasses do:[ :each |		rgSub := each asRingDefinition.		rgSub superclass: rgClass ].		packageKeys := RGContainer packageKeys.	self methodsDo:[ :mth|  			rgMethod := mth asActiveRingDefinition.			rgClass addMethod: rgMethod.			rgMethod package: (RGContainer packageOfMethod: rgMethod using: packageKeys) ].	self theMetaClass methodsDo:[ :mth|  			rgMethod := mth asActiveRingDefinition.			rgClass theMetaClass addMethod: rgMethod.			rgMethod package: (RGContainer packageOfMethod: rgMethod using: packageKeys) ].		^ rgClass! !!TClass methodsFor: '*Ring-Core-Kernel' stamp: 'SebastianTleye 7/16/2013 11:23'!asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackages: packsBoolean	"Retrieves a ring class/trait based on the receiver.	The data loaded in the class/trait (active methods, superclasses, subclasses and packages) is requested by the users.	As it may need to traverse hierarchies for retrieving super and subclasses a ring slice is created as the container for every class, method and package.	To retrieve the slice:  aRGClass environment "	| rgClass rgSlice  rgPackageKeys |		rgSlice := RGSlice named: #fromImage.	packsBoolean ifTrue: [ 		rgPackageKeys := rgSlice loadPackagesFromImage ].	rgClass := self asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: rgPackageKeys in: rgSlice.	rgSlice cleanEmptyPackages.	rgSlice loadTraitUsers.			^ rgClass! !!TClass methodsFor: '*Ring-Core-Kernel' stamp: 'SebastianTleye 7/16/2013 11:18'!asFullRingDefinition	"A behavior is converted to a ring class including its variables, methods, direct superclass, direct subclasses and the package in which is loaded.	Active methods are generated and each knows its package as well.	Note that for its direct superclass and subclasses no full definitions are requested. If you need to traverse hierarchies use #asRingDefinitionWithMethods:withSuperclasses:withSubclasses:withPackages:"		| rgClass rgSuper rgSub rgMethod packageKeys |	rgClass:= self asRingDefinition.	rgClass package: (RGContainer packageOfClass: rgClass).		self superclass notNil 		ifTrue: [ 			rgSuper := self superclass asRingDefinition.			rgClass superclass: rgSuper ]		ifFalse: [  			self isTrait ifTrue: [ 				rgSuper := Trait asRingDefinition.				rgClass superclass: rgSuper. ]			].	self subclasses do:[ :each |		rgSub := each asRingDefinition.		rgSub superclass: rgClass ].		packageKeys := RGContainer packageKeys.	self methodsDo:[ :mth|  			rgMethod := mth asActiveRingDefinition.			rgClass addMethod: rgMethod.			rgMethod package: (RGContainer packageOfMethod: rgMethod using: packageKeys) ].	self theMetaClass methodsDo:[ :mth|  			rgMethod := mth asActiveRingDefinition.			rgClass theMetaClass addMethod: rgMethod.			rgMethod package: (RGContainer packageOfMethod: rgMethod using: packageKeys) ].		^ rgClass! !!TClass methodsFor: '*Ring-Core-Kernel' stamp: 'SebastianTleye 7/16/2013 11:23'!asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackages: packsBoolean	"Retrieves a ring class/trait based on the receiver.	The data loaded in the class/trait (active methods, superclasses, subclasses and packages) is requested by the users.	As it may need to traverse hierarchies for retrieving super and subclasses a ring slice is created as the container for every class, method and package.	To retrieve the slice:  aRGClass environment "	| rgClass rgSlice  rgPackageKeys |		rgSlice := RGSlice named: #fromImage.	packsBoolean ifTrue: [ 		rgPackageKeys := rgSlice loadPackagesFromImage ].	rgClass := self asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: rgPackageKeys in: rgSlice.	rgSlice cleanEmptyPackages.	rgSlice loadTraitUsers.			^ rgClass! !!TApplyingOnClassSide methodsFor: 'fileIn/Out' stamp: 'SebastianTleye 7/12/2013 20:57'!definition	^self explicitRequirement.! !!TApplyingOnClassSide methodsFor: '*Manifest-Core' stamp: 'SebastianTleye 7/12/2013 17:40'!criticTheNonMetaclassClass	^self theNonMetaClass ! !!TApplyingOnClassSide methodsFor: 'instance variables' stamp: 'SebastianTleye 7/12/2013 18:06'!removeInstVarNamed: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newArray newString |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newArray := self instVarNames copyWithout: aString.	newString := ''.	newArray do: [:aString2 | newString := aString2 , ' ' , newString].	self instanceVariableNames: newString! !!TApplyingOnClassSide methodsFor: 'instance variables' stamp: 'SebastianTleye 7/12/2013 17:21'!addInstVarNamed: aString 	"Add the argument, aString, as one of the receiver's instance variables."	| fullString |	fullString := String streamContents: [:strm |		self instVarNames do: [:aString2 | strm nextPutAll: aString2; space].		strm nextPutAll: aString].	self instanceVariableNames: fullString! !!TApplyingOnClassSide methodsFor: 'pool variables' stamp: 'SebastianTleye 7/12/2013 17:37'!classPool	"Answer the dictionary of class variables."	^self theNonMetaClass classPool! !!TApplyingOnClassSide methodsFor: 'initialize-release' stamp: 'SebastianTleye 7/12/2013 17:25'!instanceVariableNames: instVarString	^self explicitRequirement.! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 18:08'!obsoleteSubclasses	"Answer the receiver's subclasses."	self theNonMetaClass == nil ifTrue:[^#()].	^self theNonMetaClass obsoleteSubclasses 		select:[:aSubclass| aSubclass isMeta not] 		thenCollect:[:aSubclass| aSubclass class]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses:=nil' for: m logged: false]"! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 18:05'!subclassesDo: aBlock	"Evaluate aBlock for each of the receiver's immediate subclasses."	self theNonMetaClass subclassesDo:[:aSubclass|		"The following test is for Class class which has to exclude		the Metaclasses being subclasses of Class."		aSubclass isMeta ifFalse:[aBlock value: aSubclass class]].! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 18:04'!subclasses	"Answer the receiver's subclasses."	self theNonMetaClass == nil ifTrue:[^#()].	^self theNonMetaClass subclasses 		select:[:aSubclass| aSubclass isMeta not] 		thenCollect:[:aSubclass| aSubclass class]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses:=nil' for: m logged: false]"! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 18:06'!removeObsoleteSubclass: aClass	"Do nothing."! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 17:25'!addObsoleteSubclass: aClass	"Do nothing."! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 18:06'!removeSubclass: aClass	"Do nothing."! !!TApplyingOnClassSide methodsFor: 'accessing instances and variables' stamp: 'SebastianTleye 7/12/2013 17:39'!classVarNames	"Answer a set of the names of the class variables defined in the receiver's instance."		self theNonMetaClass ifNil: [ ^ Set new ].	^self theNonMetaClass classVarNames! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 17:33'!binding	"return an association that can be used as the binding	 To share it between methods, reuse an existing one if possible"	^self methodDict 		ifEmpty: [nil -> self]		ifNotEmpty: [:dict | dict anyOne classBinding]! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 18:12'!possibleVariablesFor: misspelled continuedFrom: oldResults	^ self theNonMetaClass possibleVariablesFor: misspelled continuedFrom: oldResults! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 17:34'!bindingOf: varName	^self theNonMetaClass classBindingOf: varName! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 18:02'!wantsChangeSetLogging	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism.The metaclass follows the rule of the class itself."	^ self theNonMetaClass wantsChangeSetLogging! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 17:21'!acceptsLoggingOfCompilation	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set.  The metaclass follows the rule of the class itself."	^ self theNonMetaClass acceptsLoggingOfCompilation! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 18:01'!wantsRecompilationProgressReported	"The metaclass follows the rule of the class itself."	^ self theNonMetaClass wantsRecompilationProgressReported! !!TApplyingOnClassSide methodsFor: 'accessing' stamp: 'SebastianTleye 7/12/2013 20:49'!category	^ self theNonMetaClass category! !!TApplyingOnClassSide methodsFor: 'accessing' stamp: 'SebastianTleye 7/12/2013 18:09'!name	^self explicitRequirement.! !!TApplyingOnClassSide methodsFor: 'testing' stamp: 'SebastianTleye 7/12/2013 18:11'!isMeta	^ true! !!TApplyingOnClassSide methodsFor: 'testing' stamp: 'SebastianTleye 7/12/2013 18:10'!isSelfEvaluating	^self isObsolete not! !!TApplyingOnClassSide methodsFor: 'fileIn/Out' stamp: 'SebastianTleye 7/12/2013 20:57'!definition	^self explicitRequirement.! !!TApplyingOnClassSide methodsFor: '*Manifest-Core' stamp: 'SebastianTleye 7/12/2013 17:40'!criticTheNonMetaclassClass	^self theNonMetaClass ! !!TApplyingOnClassSide methodsFor: 'instance variables' stamp: 'SebastianTleye 7/12/2013 18:06'!removeInstVarNamed: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newArray newString |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newArray := self instVarNames copyWithout: aString.	newString := ''.	newArray do: [:aString2 | newString := aString2 , ' ' , newString].	self instanceVariableNames: newString! !!TApplyingOnClassSide methodsFor: 'instance variables' stamp: 'SebastianTleye 7/12/2013 17:21'!addInstVarNamed: aString 	"Add the argument, aString, as one of the receiver's instance variables."	| fullString |	fullString := String streamContents: [:strm |		self instVarNames do: [:aString2 | strm nextPutAll: aString2; space].		strm nextPutAll: aString].	self instanceVariableNames: fullString! !!TApplyingOnClassSide methodsFor: 'pool variables' stamp: 'SebastianTleye 7/12/2013 17:37'!classPool	"Answer the dictionary of class variables."	^self theNonMetaClass classPool! !!TApplyingOnClassSide methodsFor: 'initialize-release' stamp: 'SebastianTleye 7/12/2013 17:25'!instanceVariableNames: instVarString	^self explicitRequirement.! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 18:08'!obsoleteSubclasses	"Answer the receiver's subclasses."	self theNonMetaClass == nil ifTrue:[^#()].	^self theNonMetaClass obsoleteSubclasses 		select:[:aSubclass| aSubclass isMeta not] 		thenCollect:[:aSubclass| aSubclass class]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses:=nil' for: m logged: false]"! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 18:05'!subclassesDo: aBlock	"Evaluate aBlock for each of the receiver's immediate subclasses."	self theNonMetaClass subclassesDo:[:aSubclass|		"The following test is for Class class which has to exclude		the Metaclasses being subclasses of Class."		aSubclass isMeta ifFalse:[aBlock value: aSubclass class]].! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 18:04'!subclasses	"Answer the receiver's subclasses."	self theNonMetaClass == nil ifTrue:[^#()].	^self theNonMetaClass subclasses 		select:[:aSubclass| aSubclass isMeta not] 		thenCollect:[:aSubclass| aSubclass class]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses:=nil' for: m logged: false]"! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 18:06'!removeObsoleteSubclass: aClass	"Do nothing."! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 17:25'!addObsoleteSubclass: aClass	"Do nothing."! !!TApplyingOnClassSide methodsFor: 'class hierarchy' stamp: 'SebastianTleye 7/12/2013 18:06'!removeSubclass: aClass	"Do nothing."! !!TApplyingOnClassSide methodsFor: 'accessing instances and variables' stamp: 'SebastianTleye 7/12/2013 17:39'!classVarNames	"Answer a set of the names of the class variables defined in the receiver's instance."		self theNonMetaClass ifNil: [ ^ Set new ].	^self theNonMetaClass classVarNames! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 17:33'!binding	"return an association that can be used as the binding	 To share it between methods, reuse an existing one if possible"	^self methodDict 		ifEmpty: [nil -> self]		ifNotEmpty: [:dict | dict anyOne classBinding]! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 18:12'!possibleVariablesFor: misspelled continuedFrom: oldResults	^ self theNonMetaClass possibleVariablesFor: misspelled continuedFrom: oldResults! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 17:34'!bindingOf: varName	^self theNonMetaClass classBindingOf: varName! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 18:02'!wantsChangeSetLogging	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism.The metaclass follows the rule of the class itself."	^ self theNonMetaClass wantsChangeSetLogging! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 17:21'!acceptsLoggingOfCompilation	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set.  The metaclass follows the rule of the class itself."	^ self theNonMetaClass acceptsLoggingOfCompilation! !!TApplyingOnClassSide methodsFor: 'compiling' stamp: 'SebastianTleye 7/12/2013 18:01'!wantsRecompilationProgressReported	"The metaclass follows the rule of the class itself."	^ self theNonMetaClass wantsRecompilationProgressReported! !!TApplyingOnClassSide methodsFor: 'accessing' stamp: 'SebastianTleye 7/12/2013 20:49'!category	^ self theNonMetaClass category! !!TApplyingOnClassSide methodsFor: 'accessing' stamp: 'SebastianTleye 7/12/2013 18:09'!name	^self explicitRequirement.! !!TApplyingOnClassSide methodsFor: 'testing' stamp: 'SebastianTleye 7/12/2013 18:11'!isMeta	^ true! !!TApplyingOnClassSide methodsFor: 'testing' stamp: 'SebastianTleye 7/12/2013 18:10'!isSelfEvaluating	^self isObsolete not! !!TraitBehavior methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:33'!localSelectors	"Return a set of selectors defined locally.	The instance variable is lazily initialized. If it is nil then there	are no non-local selectors"	^ self basicLocalSelectors isNil		ifTrue: [self selectors asSet]		ifFalse: [self basicLocalSelectors].! !!TraitBehavior methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:33'!localSelectors: aSet 	self basicLocalSelectors: aSet.! !!TraitBehavior methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:33'!localSelectors	"Return a set of selectors defined locally.	The instance variable is lazily initialized. If it is nil then there	are no non-local selectors"	^ self basicLocalSelectors isNil		ifTrue: [self selectors asSet]		ifFalse: [self basicLocalSelectors].! !!TraitBehavior methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:33'!localSelectors: aSet 	self basicLocalSelectors: aSet.! !!ClassTrait methodsFor: 'initialize-release' stamp: 'SebastianTleye 7/12/2013 17:23'!instanceVariableNames: instVarString	"Compatibility purposes"! !!ClassTrait methodsFor: 'initialize-release' stamp: 'SebastianTleye 7/12/2013 17:23'!instanceVariableNames: instVarString	"Compatibility purposes"! !!OpenToolTest methodsFor: 'test browse' stamp: 'SebastianTleye 7/16/2013 10:46'!testOpenBrowseOnInstalledTraitMethod	| browser |	browser := (Class>>#localSelectors) browse.	browser changed.	browser close.! !!OpenToolTest methodsFor: 'test browse' stamp: 'SebastianTleye 7/16/2013 10:47'!testOpenBrowseOnTraitMethod	| browser |	browser := (TBehavior>>#classPool) browse.	browser changed.	browser close.! !!OpenToolTest methodsFor: 'test browse' stamp: 'SebastianTleye 7/16/2013 10:46'!testOpenBrowseOnInstalledTraitMethod	| browser |	browser := (Class>>#localSelectors) browse.	browser changed.	browser close.! !!OpenToolTest methodsFor: 'test browse' stamp: 'SebastianTleye 7/16/2013 10:47'!testOpenBrowseOnTraitMethod	| browser |	browser := (TBehavior>>#classPool) browse.	browser changed.	browser close.! !!Class methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:32'!localSelectors	"Return a set of selectors defined locally.	The instance variable is lazily initialized. If it is nil then there	are no non-local selectors"	^ self basicLocalSelectors isNil		ifTrue: [self selectors asSet]		ifFalse: [self basicLocalSelectors].! !!Class methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:33'!localSelectors: aSet 	self basicLocalSelectors: aSet.! !!Class methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:32'!localSelectors	"Return a set of selectors defined locally.	The instance variable is lazily initialized. If it is nil then there	are no non-local selectors"	^ self basicLocalSelectors isNil		ifTrue: [self selectors asSet]		ifFalse: [self basicLocalSelectors].! !!Class methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:33'!localSelectors: aSet 	self basicLocalSelectors: aSet.! !!Metaclass methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:34'!localSelectors: aSet 	self basicLocalSelectors: aSet.! !!Metaclass methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:34'!localSelectors	"Return a set of selectors defined locally.	The instance variable is lazily initialized. If it is nil then there	are no non-local selectors"	^ self basicLocalSelectors isNil		ifTrue: [self selectors asSet]		ifFalse: [self basicLocalSelectors].! !!Metaclass methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:34'!localSelectors: aSet 	self basicLocalSelectors: aSet.! !!Metaclass methodsFor: 'accessing' stamp: 'SebastianTleye 7/15/2013 17:34'!localSelectors	"Return a set of selectors defined locally.	The instance variable is lazily initialized. If it is nil then there	are no non-local selectors"	^ self basicLocalSelectors isNil		ifTrue: [self selectors asSet]		ifFalse: [self basicLocalSelectors].! !Metaclass removeSelector: #acceptsLoggingOfCompilation!Metaclass removeSelector: #addInstVarNamed:!Metaclass removeSelector: #addObsoleteSubclass:!Metaclass removeSelector: #binding!Metaclass removeSelector: #bindingOf:!Metaclass removeSelector: #classPool!Metaclass removeSelector: #classVarNames!Metaclass removeSelector: #criticTheNonMetaclassClass!Metaclass removeSelector: #hasTraitComposition!Metaclass removeSelector: #isMeta!Metaclass removeSelector: #isSelfEvaluating!Metaclass removeSelector: #obsoleteSubclasses!Metaclass removeSelector: #possibleVariablesFor:continuedFrom:!Metaclass removeSelector: #removeInstVarNamed:!Metaclass removeSelector: #removeObsoleteSubclass:!Metaclass removeSelector: #removeSubclass:!Metaclass removeSelector: #subclasses!Metaclass removeSelector: #subclassesDo:!Metaclass removeSelector: #wantsChangeSetLogging!Metaclass removeSelector: #wantsRecompilationProgressReported!!Metaclass reorganize!(#'accessing hierarchy protocol' hasClassSide)(#'*Tools-Debugger' canonicalArgumentName)(#'instance creation' new)(#'*NativeBoost-Core' externalTypeAlias:)(#'fileIn/Out' nonTrivial definition fileOutOn:moveSource:toFile: fileOutOn:moveSource:toFile:initializing: fileOutInitializerOn:)(#'instance variables' removeInstVarNamed: addInstVarNamed:)(#accessing environment name category traitComposition basicLocalSelectors basicLocalSelectors: localSelectors: soleInstance localSelectors traitComposition:)(#'class hierarchy' subclassesDo: removeSubclass: subclasses addObsoleteSubclass: addSubclass: removeObsoleteSubclass: obsoleteSubclasses)(#'accessing parallel hierarchy' classClass baseClass)(#'*Ring-Core-Kernel' asFullRingDefinition asRingDefinition)(#compiling possibleVariablesFor:continuedFrom: acceptsLoggingOfCompilation wantsChangeSetLogging binding bindingOf: wantsRecompilationProgressReported)(#testing canZapMethodDictionary isMeta isSelfEvaluating isObsolete isAnonymous)(#'accessing instances and variables' classVarNames)(#'pool variables' classPool)(#'initialize-release' uses:instanceVariableNames: adoptInstance:from: instanceVariableNames:)(#composition noteNewBaseTraitCompositionApplied: assertConsistantCompositionsForNew:)(#copying veryDeepCopyWith: postCopy)(#'*Manifest-Core' criticTheNonMetaclassClass)(#'*Fuel' fuelAccept:)!Class removeSelector: #asFullRingDefinition!Class removeSelector: #asRingDefinitionWithMethods:withSuperclasses:withSubclasses:withPackages:!Behavior removeSelector: #basicLocalSelectors:!ClassTrait removeSelector: #baseClass:traitComposition:methodDict:localSelectors:organization:!ClassTrait removeSelector: #binding!ClassTrait removeSelector: #category!ClassTrait removeSelector: #includesBehavior:!ClassTrait removeSelector: #isMeta!ClassTrait removeSelector: #isSelfEvaluating!ClassTrait removeSelector: #subclassesDo:!ClassTrait removeSelector: #traitComposition:methodDict:localSelectors:organization:!!ClassTrait reorganize!(#'*Manifest-Core' criticTheNonMetaclassClass)(#'pool variables' classPool)(#'*refactoring-core' soleInstance)(#'initialize-release' instanceVariableNames:)(#'instance variables' removeInstVarNamed: addInstVarNamed:)(#'accessing hierarchy protocol' hasClassSide)(#initialize initializeFrom: initializeWithBaseTrait:)(#'filein/out' definition)(#'class hierarchy' subclassesDo: subclasses addObsoleteSubclass: removeSubclass: addSubclass: removeObsoleteSubclass: obsoleteSubclasses)(#testing isMeta isSelfEvaluating)(#composition noteNewBaseTraitCompositionApplied: assertConsistantCompositionsForNew: uses:)(#'*Monticello' asMCDefinition)(#'accessing instances and variables' classVarNames)(#copying copy)(#accessing category name)(#'*Ring-Core-Kernel' asFullRingDefinition asRingDefinition)(#'accessing parallel hierarchy' classTrait baseTrait: isClassTrait baseTrait isBaseTrait classTrait:)(#'*Fuel' fuelAccept:)(#compiling possibleVariablesFor:continuedFrom: compile:classified:withStamp:notifying:logSource: binding wantsChangeSetLogging acceptsLoggingOfCompilation bindingOf: wantsRecompilationProgressReported)!Trait removeSelector: #asFullRingDefinition!Trait removeSelector: #asRingDefinitionWithMethods:withSuperclasses:withSubclasses:withPackages:!BehaviorTest removeSelector: #testChange!TBehavior removeSelector: #basicLocalSelectors!TBehavior removeSelector: #basicLocalSelectors:!TBehavior removeSelector: #localSelectors!TBehavior removeSelector: #localSelectors:!!TClass reorganize!(#'*GroupManagerUI' prettyName)(#accessing classPool classPoolFrom: classPool: setName:)(#'self evaluating' isSelfEvaluating)(#'*Spec-Builder' addSourceCode:into: addInstVarNamed:type: subclass:category:)(#testing hasAbstractMethods isObsolete hasMethods isAnonymous)(#'accessing class hierarchy' removeSubclass: addSubclass: subclasses subclasses: subclassesDo:)(#'class name' rename:)(#'accessing parallel hierarchy' hasClassSide)(#'*HelpSystem-Core' asHelpTopic)(#'accessing method dictionary' addSelector:withMethod:notifying: addSelectorSilently:withMethod:)(#'initialize-release' sharing: declare: superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools: removeFromSystemUnlogged unload obsolete name:traitComposition:methodDict:localSelectors:organization: superclass:methodDictionary:format: removeFromSystem removeFromSystem:)(#'*Ring-Core-Kernel' asFullRingDefinition asRingDefinitionWithMethods:withSuperclasses:withSubclasses:withPackages:)(#'*FuelTests' renameSilently:)(#traits applyChangesOfNewTraitCompositionReplacing:)(#'subclass creation' classBuilder variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: subclass: weakSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category: variableWordSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category: variableSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category: newSubclass weakSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: subclass:instanceVariableNames: subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: subclass:uses: variableByteSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category: subclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category: variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:)(#viewer externalName)(#'instance variables' removeInstVarNamed:)(#'fileIn/Out' shouldFileOutPools removeFromChanges fileOutSharedPoolsOn: withClassVersion: fileOutOn:moveSource:toFile: fileOut fileOutOn:moveSource:toFile:initializing: shouldFileOutPool: hasSharedPools fileOutPool:onFileStream: fileOutInitializerOn:)(#'*Manifest-Core' criticTheNonMetaclassClass)(#organization category: category)(#'pool variables' usesLocalPoolVarNamed: addSharedPool: sharedPoolOfVarNamed: usesPoolVarNamed: removeSharedPool: sharedPools allSharedPools)(#compiling possibleVariablesFor:continuedFrom: compileAll binding compile:notifying: compileAllFrom: innerBindingOf: bindingOf: reformatAll)(#'class variables' allClassVarNames classVarNamed: removeClassVarNamed: addClassVarNamed: ensureClassPool classVarNames hasClassVarNamed: classVarNamed:put: usesClassVarNamed:)(#private isValidTraitName: setName:andRegisterInCategory:environment:)(#copying duplicateClassWithNewName:)!