'From Pharo2.0a of ''18 April 2012'' [Latest update: #20049] on 5 May 2012 at 1:07:21 pm'!!TTransformationCompatibility methodsFor: 'enquiries' stamp: 'mada 5/5/2012 11:40'!collectMethodsFor: aSelector into: methodDescription	(self includesSelector: aSelector) ifTrue: [ 		methodDescription addLocatedMethod: 			(self compiledMethodAt: aSelector)		]! !!TraitMethodDescription methodsFor: 'accessing' stamp: 'mada 5/5/2012 11:24'!providedLocatedMethod	| locatedMethod aLocatedMethod refOrigin |	locatedMethod := nil.	self locatedMethods ifEmpty: [ ^ nil].	self locatedMethods size > 1		ifTrue: [ 	aLocatedMethod := self locatedMethods anyOne.						refOrigin := (aLocatedMethod methodClass >> aLocatedMethod selector) origin.						(self locatedMethods 							allSatisfy: [:each | each origin == refOrigin])						ifTrue: [^ aLocatedMethod].  ].		self locatedMethods do: [:each |		each isProvided ifTrue: [			locatedMethod isNil ifFalse: [^nil].			locatedMethod := each]].	^locatedMethod! !!TraitMethodDescription methodsFor: 'accessing' stamp: 'mada 5/5/2012 11:22'!requiredMethod	| argumentNames numberOfArguments binary |	self isRequired ifFalse: [^nil].	self size = 1 ifTrue: [^self locatedMethods anyOne].	argumentNames := self getArgumentNames.	binary := self isBinarySelector.	numberOfArguments := binary		ifTrue: [1]		ifFalse: [argumentNames size + 2].	 ^self		generateMethod: self selector		withMarker: CompiledMethod implicitRequirementMarker		forArgs: argumentNames size		binary: binary.! !!TraitMethodDescription methodsFor: 'enumeration' stamp: 'mada 5/5/2012 11:24'!methodsDo: aBlock	self locatedMethods do: [:each |		aBlock value: each ]! !!TraitMethodDescription methodsFor: 'initialization' stamp: 'mada 5/5/2012 12:57'!initialize	super initialize.	locatedMethods := IdentitySet new! !!TraitMethodDescription methodsFor: 'testing' stamp: 'mada 5/5/2012 11:30'!isAliasSelector	"Return true if the selector is an alias (if it is different	from the original selector) or already an aliased method	in the original location (recursively search the compositions).	Return false, if not or if we have a conflict."		| locatedMethod |	^self size = 1 and: [		locatedMethod := self locatedMethods anyOne.		(locatedMethod selector ~= self selector) or: [			locatedMethod methodClass isAliasSelector: self selector]]! !!TraitMethodDescription methodsFor: 'testing' stamp: 'mada 5/5/2012 11:25'!isConflict	| count originMethodReferenciel |	count := 0.	self locatedMethods size > 1		ifTrue: 			["If they are more than 1 located method, then check whether these methods have the same origin"			originMethodReferenciel := self locatedMethods anyOne  origin.			(self locatedMethods allSatisfy: [:each | each origin == originMethodReferenciel])				ifTrue: [ ^ false ]].	self methodsDo: [:each |		each isProvided ifTrue: [			count := count + 1.			count > 1 ifTrue: [^true]]].	^false! !!TraitMethodDescription methodsFor: 'testing' stamp: 'mada 5/5/2012 11:25'!isRequired	self isEmpty ifTrue: [^ false].	^ self locatedMethods allSatisfy: [:each | each isRequired]! !!RGMethodDefinition methodsFor: 'traits' stamp: 'mada 5/5/2012 13:07'!argumentNames	"Return an array with the argument names of the method's selector"	^ self compiledMethod argumentNames! !!TraitBehavior methodsFor: 'traits' stamp: 'mada 5/5/2012 11:33'!traitsProvidingSelector: aSymbol	| result |	result := OrderedCollection new.	self hasTraitComposition ifFalse: [^result].	(self traitComposition methodDescriptionsForSelector: aSymbol)		do: [:methodDescription | methodDescription selector = aSymbol ifTrue: [			result addAll: (methodDescription locatedMethods				collect: [:each | each methodClass])]].	^result! !!TraitDescription methodsFor: 'enquiries' stamp: 'mada 5/5/2012 11:36'!collectMethodsFor: aSelector into: methodDescription	(self includesSelector: aSelector) ifTrue: [ 		methodDescription addLocatedMethod: 			(self compiledMethodAt: aSelector)		]! !!TraitTest methodsFor: 'testing' stamp: 'mada 5/5/2012 13:04'!testOrigin	| tr1 tr2 tr3 tr23 aMethodDescription |	tr1 := self createTraitNamed: #TTT1 uses: {}.	tr2 := self createTraitNamed: #TTT2 uses: {tr1}.	tr3 := self createTraitNamed: #TTT3 uses: {tr1}.	tr23 := self createTraitNamed: #TTT23 uses: {tr3 + tr2}.		tr1 compile: 'foo ^ 4'.	self assert: (tr1 >> #foo) origin == tr1.	self assert: (tr2 >> #foo) origin == tr1.	self assert: (tr3 >> #foo) origin == tr1.		"-----------"	"For TR2"	aMethodDescription := tr2 traitComposition methodDescriptionForSelector: #foo.	self assert: (aMethodDescription locatedMethods size = 1).	self assert: (aMethodDescription locatedMethods includes: ( tr1 >>  #foo)).	self assert: (aMethodDescription providedLocatedMethod notNil).		"The method is provided, it cannot be nil"	self assert: (aMethodDescription providedMethod notNil).		self assert: (aMethodDescription isProvided).				self assert: (tr2 traitComposition traitProvidingSelector: #foo) == tr1.	self assert: (tr2 >> #foo) origin == tr1.	"-----------"		"-----------"	"For TR23"	aMethodDescription := tr23 traitComposition methodDescriptionForSelector: #foo.	self assert: (aMethodDescription locatedMethods size = 2).	self assert: (aMethodDescription locatedMethods includes: (tr2 >> #foo)).	self assert: (aMethodDescription locatedMethods includes: (tr3 >> #foo)).	self assert: (aMethodDescription providedLocatedMethod notNil).		"The method is provided, it cannot be nil"	self assert: (aMethodDescription providedMethod notNil).		self assert: (aMethodDescription isProvided).				self assert: (tr23 traitComposition traitProvidingSelector: #foo) == tr1.	self assert: (tr23 >> #foo) origin == tr1.	"----------"! !!CompiledMethod methodsFor: 'source code management' stamp: 'mada 5/5/2012 12:57'!argumentNames	"Return an array with the argument names of the method's selector"	| keywords stream argumentNames delimiters |	delimiters := {Character space. Character cr}.	keywords := self selector keywords.	stream := self getSource readStream.	argumentNames := OrderedCollection new.	keywords do: [ :each | | argumentName |		stream match: each.		[stream peekFor: Character space] whileTrue.		argumentName := ReadWriteStream on: String new.		[(delimiters includes: stream peek) or: [stream peek isNil]]			whileFalse: [argumentName nextPut: stream next].		argumentName isEmpty ifFalse: [			argumentNames add: argumentName contents trimBoth]].	^(argumentNames copyFrom: 1 to: self numArgs) asArray! !!CompiledMethod methodsFor: 'testing' stamp: 'mada 5/5/2012 11:29'!isBinarySelector	^self selector		allSatisfy: [:each | each isSpecial]! !!Behavior methodsFor: 'traits' stamp: 'mada 5/5/2012 11:34'!traitsProvidingSelector: aSymbol	| result |	result := OrderedCollection new.	self hasTraitComposition ifFalse: [^result].	(self traitComposition methodDescriptionsForSelector: aSymbol)		do: [:methodDescription | methodDescription selector = aSymbol ifTrue: [			result addAll: (methodDescription locatedMethods				collect: [:each | each methodClass])]].	^result! !