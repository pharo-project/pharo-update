'From Pharo3.0 of 18 March 2013 [Latest update: #30290] on 22 July 2013 at 1:13 pm'!MetacelloNullRecordingMCSpecLoader removeSelector: #resolvePackageSpecReferences:gofer:!MetacelloMCPartiallyLoadedStatus class removeSelector: #new!!MCVersionLoader methodsFor: 'loading' stamp: 'bf 3/16/2006 19:03'!load	self loadWithNameLike: versions first info name.! !!MCVersionLoader methodsFor: 'loading' stamp: 'bf 3/16/2006 19:03'!load	self loadWithNameLike: versions first info name.! !MCSqueaksourceRepository removeSelector: #asCreationTemplate!!JobProgressMorph methodsFor: 'initialize' stamp: 'BenjaminVanRyseghem 2/19/2013 15:27'!initialize	"Initialization code for JobProgressMorph"	super initialize.	self addDependent: SystemProgressMorph uniqueInstance.! !!JobProgressMorph methodsFor: 'initialize' stamp: 'BenjaminVanRyseghem 2/19/2013 15:27'!initialize	"Initialization code for JobProgressMorph"	super initialize.	self addDependent: SystemProgressMorph uniqueInstance.! !!PluggableTextMorphWithLimits methodsFor: 'initialize' stamp: 'BenjaminVanRyseghem 8/6/2012 00:45'!initialize	"Initialization code for PluggableTextMorphWithLimits"	super initialize.	locked := false.	lockIcon := self defaultOpenMorph.	self addIcon.	lockIcon on: #mouseEnter send: #colorize to: self.	lockIcon on: #mouseLeave send: #decolorize to: self.	lockIcon on: #click send: #toggleLock to: self! !!PluggableTextMorphWithLimits methodsFor: 'initialize' stamp: 'BenjaminVanRyseghem 8/6/2012 00:45'!initialize	"Initialization code for PluggableTextMorphWithLimits"	super initialize.	locked := false.	lockIcon := self defaultOpenMorph.	self addIcon.	lockIcon on: #mouseEnter send: #colorize to: self.	lockIcon on: #mouseLeave send: #decolorize to: self.	lockIcon on: #click send: #toggleLock to: self! !PaginatedMorphTreeModel removeSelector: #chunkSize:!PaginatedMorphTreeModel removeSelector: #defaultChunkSize!PaginatedMorphTreeModel removeSelector: #defaultPageSize!PaginatedMorphTreeModel removeSelector: #pageSize:!ClassTreeExample removeSelector: #expandAllFromNode:!BorderedMorph removeSelector: #useRoundedCorners!ClassListExample removeSelector: #defaultChunkSize!Morph removeSelector: #stepTime!NativeBoostMac32 removeSelector: #newAssembler!NBWin32Heap removeSelector: #nbCallingConvention!!MultipleMethodsEditor methodsFor: 'initialize' stamp: 'BenjaminVanRyseghem 8/6/2012 00:56'!initialize	"Initialization code for MultipleMethodsEditor"	super initialize.	self changeProportionalLayout.	self color: Color white.	lock := false.	buttonsContainer := PanelMorph new							changeTableLayout;							listDirection: #rightToLeft;							hResizing: #spaceFill;							vResizing: #spaceFill;							yourself.								editors := OrderedCollection new.	container := self newProportionalPanelMorph.						self updateLayoutForSingle! !!MultipleMethodsEditor methodsFor: 'initialize' stamp: 'BenjaminVanRyseghem 8/6/2012 00:56'!initialize	"Initialization code for MultipleMethodsEditor"	super initialize.	self changeProportionalLayout.	self color: Color white.	lock := false.	buttonsContainer := PanelMorph new							changeTableLayout;							listDirection: #rightToLeft;							hResizing: #spaceFill;							vResizing: #spaceFill;							yourself.								editors := OrderedCollection new.	container := self newProportionalPanelMorph.						self updateLayoutForSingle! !!MultipleMethodsEditorAllButtonModel methodsFor: 'protocol' stamp: 'BenjaminVanRyseghem 8/6/2012 18:22'!initialize	"Initialization code for MultipleMethodsEditorAllButtonModel"	super initialize.	state := true.! !!MultipleMethodsEditorAllButtonModel methodsFor: 'protocol' stamp: 'BenjaminVanRyseghem 8/6/2012 18:22'!initialize	"Initialization code for MultipleMethodsEditorAllButtonModel"	super initialize.	state := true.! !!MultipleMethodsEditorButtonModel methodsFor: 'protocol' stamp: 'BenjaminVanRyseghem 8/6/2012 18:18'!initialize	"Initialization code for MultipleMethodsEditorButtonModel"	super initialize.	state := false! !!MultipleMethodsEditorButtonModel methodsFor: 'protocol' stamp: 'BenjaminVanRyseghem 8/6/2012 18:18'!initialize	"Initialization code for MultipleMethodsEditorButtonModel"	super initialize.	state := false! !!NautilusMCBindings methodsFor: 'initialization'!initialize	"Initialization code for NautilusMCBindings"	super initialize.	bindingsRtoMC := IdentityDictionary new.	bindingsMCtoR := IdentityDictionary new.	self registerToMCAnnouncements.! !!NautilusMCBindings methodsFor: 'initialization'!initialize	"Initialization code for NautilusMCBindings"	super initialize.	bindingsRtoMC := IdentityDictionary new.	bindingsMCtoR := IdentityDictionary new.	self registerToMCAnnouncements.! !!AbstractNautilusUI methodsFor: 'menus behavior'!buildInitializeCodeFor: aClass 		^ String streamContents: [:str | str << 'initialize';cr.		str tab << '"Initialization code for '<<aClass name<<'"';cr;cr.		str tab << 'super initialize.';cr.		aClass instVarNames sort do: [:name | str cr tab << name << ' := nil.' ]].	! !!AbstractNautilusUI methodsFor: 'menus behavior'!buildInitializeCodeFor: aClass 		^ String streamContents: [:str | str << 'initialize';cr.		str tab << '"Initialization code for '<<aClass name<<'"';cr;cr.		str tab << 'super initialize.';cr.		aClass instVarNames sort do: [:name | str cr tab << name << ' := nil.' ]].	! !!NautilusMCBindings class methodsFor: 'initialization'!initialize	"Initialization code for NautilusMCBindings class"	super initialize.		RPackageOrganizer default packages do: [:p | self default mcPackageFor: p ]! !!NautilusMCBindings class methodsFor: 'initialization'!initialize	"Initialization code for NautilusMCBindings class"	super initialize.		RPackageOrganizer default packages do: [:p | self default mcPackageFor: p ]! !!NautilusUI methodsFor: 'initialization' stamp: 'BenjaminVanRyseghem 5/14/2012 12:44'!initialize	"Initialization code for NautilusUI"	super initialize.	categoryWidget := CategoryWidget model: self.	methodWidget := MethodWidget model: self.! !!NautilusUI methodsFor: 'initialization' stamp: 'BenjaminVanRyseghem 5/14/2012 12:44'!initialize	"Initialization code for NautilusUI"	super initialize.	categoryWidget := CategoryWidget model: self.	methodWidget := MethodWidget model: self.! !AbstractNautilusUITest removeSelector: #tearDown!NautilusMCBindings initialize!AbstractNautilusUI removeSelector: #guessTypeForName:!NOCController class removeSelector: #cleanUp!NOCController class removeSelector: #initialize!PackageOrganizer class removeSelector: #new!MCFileRepositoryInspector class removeSelector: #taskbarIcon!PSMCChangeWrapper removeSelector: #theme!!IconicListItem methodsFor: 'initialize' stamp: 'BenjaminVanRyseghem 5/6/2013 23:24'!initialize	"Initialization code for IconicListItem"	super initialize.	self 			changeTableLayout;		listDirection: #leftToRight;		cellPositioning: #center;		cellInset: 2;		borderWidth: 0;		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		extent: 20@16.! !!IconicListItem methodsFor: 'initialize' stamp: 'BenjaminVanRyseghem 5/6/2013 23:24'!initialize	"Initialization code for IconicListItem"	super initialize.	self 			changeTableLayout;		listDirection: #leftToRight;		cellPositioning: #center;		cellInset: 2;		borderWidth: 0;		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		extent: 20@16.! !!PluggableTextFieldMorph methodsFor: 'initialization' stamp: 'EstebanLorenzano 12/6/2012 13:37'!initialize	"Initialization code for PluggableEncryptedTextFieldMorph"	super initialize.	textMorphClass := TextMorphForFieldView.	self beDecrypted! !!PluggableTextFieldMorph methodsFor: 'initialization' stamp: 'EstebanLorenzano 12/6/2012 13:37'!initialize	"Initialization code for PluggableEncryptedTextFieldMorph"	super initialize.	textMorphClass := TextMorphForFieldView.	self beDecrypted! !!DropListItem methodsFor: 'initialization' stamp: 'SeanDeNigris 4/15/2013 21:32'!initialize	"Initialization code for DropListItem"	super initialize.	actionHolder := [] asValueHolder.	displayBlock := [ :e | e printString ].! !!DropListItem methodsFor: 'initialization' stamp: 'SeanDeNigris 4/15/2013 21:32'!initialize	"Initialization code for DropListItem"	super initialize.	actionHolder := [] asValueHolder.	displayBlock := [ :e | e printString ].! !ListDialogWindow removeSelector: #initialFilter:!StandardWindow removeSelector: #close!StandardWindow removeSelector: #makeBorderless!PharoOrangeTheme class removeSelector: #veryLightSelectionColor!MorphicUIManager removeSelector: #theme!!MorphicUIManager reorganize!('events' onPrimitiveError: onDebug:context:title:full: onSnapshot: onEventSensorStartup:)('private' openPolymorphComparisonFrom:to:belongingTo:from:labeled:inWindowLabeled: openModal: activate deactivate)('services' fileSave:path: chooseFullFileName:extensions:path:preview: fileSave:extensions:path: message: deny: questionWithoutCancel: chooseColor: chooseDropList:title:list: chooseDropList:list: longMessage:title: textEntry:title:entryText: questionWithoutCancel:title: fileOpen:extensions:path:preview: alert: proceed:title: enterOrRequestFrom:values:lines:title: fileOpen:extensions:path: alert:title: textEntry:title: chooseColor:title: fileSave:extensions: chooseFont: message:title: centeredAlert:title:configure: chooseFileName:extensions:path:preview: fileSave: question: abort:title: proceed: textEntry: chooseFont deny:title: enterOrRequestFrom:lines:title: alert:title:configure: chooseDirectory:path: chooseColor question:title: abort: chooseOrRequestFrom:values:lines:title: confirm:trueChoice:falseChoice: chooseFrom:lines:message:title: confirm:trueChoice:falseChoice:cancelChoice:default: fileOpen:extensions: fileOpen: chooseDirectory: chooseOrRequestFrom:lines:title: chooseFrom:values:lines:message:title:)('ui requests' chooseFrom:values:lines:title: fileExistsDefaultAction: chooseFileMatching:label: edit:label:accept: restoreDisplayAfter: checkForNewDisplaySize request:initialAnswer:entryCompletion: request:initialAnswer: confirm:orCancel: request:initialAnswer:title:entryCompletion: fontFromUser: chooseFullFileNameMatching:label: request:initialAnswer:centerAt: confirm: unhandledErrorDefaultAction: messageSet:inMorphicWindowLabeled: newDisplayDepthNoRestore: syntaxErrorNotificationDefaultAction: informUserDuring: onFontsChanged confirm:label: restoreDisplay menuClass lowSpaceWatcherDefaultAction: chooseFrom:lines:title: openComparisonFrom:to:belongingTo:from:labeled:inWindowLabeled: warningDefaultAction: request:initialAnswer:title: currentWorld chooseDirectory:from: inform: fileDoesNotExistsDefaultAction: requestPassword: messageNames:inMorphicWindowWithInitialSearchString: openDebuggerOn:context:label:contents:fullView: newMenuIn:for: explorer:for:withLabel: multiLineRequest:initialAnswer:answerHeight:)('controls' newExpander:for: newButtonFor:action:getEnabled:label:help: newCloseButtonFor: newToolbar: newMorphDropListFor:list:getSelected:setSelected:help: newButtonFor:action:label:help: newSliderFor:getValue:setValue:help: newOKButtonFor: newGroupbox newDropListFor:list:getSelected:setSelected:getEnabled:useIndex:help: newToolDockingBar newTextEditorFor:getText:setText:getEnabled: newGroupboxForAll: newWindowFor:title: newHSVASelector:help: newIncrementalSliderFor:getValue:setValue:min:max:quantum:getEnabled:help: newYesButtonFor: newFuzzyLabelFor:label:offset:alpha:getEnabled: newGroupbox:for: newTextEntryFor:getText:setText:getEnabled:help:entryCompletion: newColorPresenterFor:getColor:help: newTextEditorFor:getText:setText:getEnabled:menu: newString:font:style: newBasicTextEditorFor:getText:setText: newEmbeddedMenu newNoButtonFor: newTitle:for: newAlphaImage:help: newTabGroup: newMorphListFor:list:getSelected:setSelected:help: newColorChooserFor:getColor:setColor:help: newLabel: newMenu newWorkArea newHueSelector:getHue:setHue:help: newSVSelector:help: newMorphListFor:list:getSelected:setSelected:getEnabled:help: newAutoAcceptTextEntryFor:get:set:class:getEnabled:font:help: newLabelFor:label:getEnabled: newPanel newHSVSelector:help: newYesButton newScrollPaneFor: newStack: newMorphDropListFor:list:getSelected:setSelected:getEnabled:help: newDialogPanel newAutoAcceptTextEntryFor:get:set:class:getEnabled:help: newSeparator newString: newBracketSliderFor:getValue:setValue:min:max:quantum:getEnabled:help: newBalloonHelp:for:corner: newImageFor:get:help: newAutoAcceptTextEntryFor:getText:setText:getEnabled:font:help:entryCompletion: newButtonFor:getState:action:arguments:getEnabled:label:help: newAlphaSelector:getAlpha:setAlpha:help: newRow newMenuFor: newVerticalSeparator newPluggableDialogWindow:for: newAutoAcceptTextEntryFor:getText:setText:getEnabled:font:help: newAutoAcceptTextEntryFor:get:set:class:getEnabled:font:help:entryCompletion: newCheckboxFor:getSelected:setSelected:label:help: newAutoAcceptTextEntryFor:getText:setText:getEnabled:help: newAutoAcceptTextEditorFor:getText:setText:getEnabled: newCancelButton newTreeFor:list:selected:changeSelected: newRadioButtonFor:getSelected:setSelected:getEnabled:label:help: newAutoAcceptTextEntryFor:get:set:class:getEnabled:help:entryCompletion: newRadioButtonFor:getSelected:setSelected:label:help: newTextEntryFor:getText:setText:help: newExpander:forAll: newFuzzyLabelFor:label:getEnabled: newButtonLabelFor:label:getEnabled: newGroupbox: newAutoAcceptTextEntryFor:getText:setText:getEnabled:help:entryCompletion: newSliderFor:getValue:setValue:getEnabled:help: newListFor:list:selected:changeSelected:help: newToolSpacer newColumn: newButtonLabel: newPluggableDialogWindow newLabelGroup:font:labelColor: newOKButtonFor:getEnabled: newBasicTextEditorFor:getText:setText:getEnabled:menu: newCheckboxFor:getSelected:setSelected:getEnabled:getLabel:help: newSliderFor:getValue:setValue:min:max:quantum:getEnabled:help: newText: newString:style: newNoButton newCheckboxFor:getSelected:setSelected:getEnabled:label:help: newCloseButton newBasicTextEditorFor:getText:setText:getEnabled: newRow: newDropListFor:list:getSelected:setSelected:getEnabled:help: newCloseControlFor:action:help: newButtonFor:getState:action:arguments:getEnabled:labelForm:help: newToolbar newGroupbox:forAll: newTextEntryFor:get:set:class:getEnabled:help: newEditableDropListFor:list:getSelected:setSelected:addToList:ghostText:getEnabled:help: newLabelGroup: newOKButton newGroupboxFor: newEditableDropListFor:list:getSelected:setSelected:addToList:class:default:ghostText:getEnabled:useIndex:help: newFuzzyLabel: newBalloonHelp:for: newToolbarHandle newCancelButtonFor: newImage:size: newPluggableDialogWindow: newStack newBracketSliderFor:getValue:setValue:min:max:quantum:help: newDropListFor:list:getSelected:setSelected:help: newMultistateButton newListFor:list:selected:changeSelected:icon:getEnabled:help: newButtonFor:getState:action:arguments:getEnabled:getLabel:help: newImage: newOverflowRowForAll: newColorChooserFor:getColor:setColor:getEnabled:help: newExpander: newListFor:list:selected:changeSelected:getEnabled:help: newMorphDropListFor:list:getSelected:setSelected:getEnabled:useIndex:help: newTextEditorFor:getText:setText: newLabelFor:getLabel:getEnabled: newTextEntryFor:getText:setText:getEnabled:help:)('global state' world)('settings' interactiveParserFor:)('ui process' interruptName:preemptedProcess: spawnNewProcess terminateUIProcess resumeUIProcess: uiProcess defer:)('accessing' preferredCornerStyle modalMorph interactiveParser interactiveParser:)!PluggableTreeMorph removeSelector: #getMenuSelector!UIThemeVistary removeSelector: #errorIcon!UIThemeVistary removeSelector: #infoIcon!UIThemeVistary removeSelector: #lockIcon!UIThemeVistary removeSelector: #questionIcon!UIThemeVistary removeSelector: #smallDebugIcon!UIThemeVistary removeSelector: #smallErrorIcon!UIThemeVistary removeSelector: #smallInfoIcon!UIThemeVistary removeSelector: #smallLockIcon!UIThemeVistary removeSelector: #smallQuestionIcon!UIThemeVistary removeSelector: #smallWarningIcon!UIThemeVistary removeSelector: #warningIcon!SearchMorph removeSelector: #content!ColorChooserMorph removeSelector: #enabledString!RBBlockLintRule subclass: #RBRepeteadMethodsInTheSuperclassRule	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Refactoring-Critics-BlockRules'!RBBlockLintRule subclass: #RBExplicitRequirementMethodsRule	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Refactoring-Critics-BlockRules'!RBBlockLintRule subclass: #RBLocalMethodsOfAClassNotInItsTraitComposition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Refactoring-Critics-BlockRules'!!ClassTestCase methodsFor: '*Refactoring-Critics' stamp: 'SebastianTleye 7/19/2013 12:45'!assertValidLintRule: aLintRule	| result |	result := aLintRule runOnEnvironment: self targetClassEnvironment.	self assert: result isEmpty.! !!ClassTestCase methodsFor: '*Refactoring-Critics' stamp: 'SebastianTleye 7/19/2013 11:25'!targetClassEnvironment	^RBClassEnvironment class: self targetClass.! !!ClassTestCase methodsFor: '*Refactoring-Critics' stamp: 'SebastianTleye 7/19/2013 12:45'!assertValidLintRule: aLintRule	| result |	result := aLintRule runOnEnvironment: self targetClassEnvironment.	self assert: result isEmpty.! !!ClassTestCase methodsFor: '*Refactoring-Critics' stamp: 'SebastianTleye 7/19/2013 11:25'!targetClassEnvironment	^RBClassEnvironment class: self targetClass.! !!RBRepeteadMethodsInTheSuperclassRule methodsFor: 'running' stamp: 'SebastianTleye 7/19/2013 14:54'!checkClass: aContext 	"The comparison between methods is made using the ast, this is better than comparing source code only since it does not take into account identations, extra parenthesis, etc"	| selectedClass |	selectedClass := aContext selectedClass.		selectedClass methods do: [ :method | | overridedSuperclass |		overridedSuperclass := selectedClass allSuperclasses detect: [ :superclass | superclass includesSelector: method selector ] ifNone: [ nil ].		overridedSuperclass ifNotNil: [ 			(method ast = (overridedSuperclass>>method selector) ast) 					ifTrue: [result addClass: aContext selectedClass selector: method selector ]]].! !!RBRepeteadMethodsInTheSuperclassRule methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 13:40'!name	^ 'Repeated method in the superclasses'! !!RBRepeteadMethodsInTheSuperclassRule methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 12:56'!rationale	^ 'If a class is overriding a method, it should use a different code. Is meaningless have a method in a class and in its superclass'! !!RBRepeteadMethodsInTheSuperclassRule methodsFor: 'running' stamp: 'SebastianTleye 7/19/2013 14:54'!checkClass: aContext 	"The comparison between methods is made using the ast, this is better than comparing source code only since it does not take into account identations, extra parenthesis, etc"	| selectedClass |	selectedClass := aContext selectedClass.		selectedClass methods do: [ :method | | overridedSuperclass |		overridedSuperclass := selectedClass allSuperclasses detect: [ :superclass | superclass includesSelector: method selector ] ifNone: [ nil ].		overridedSuperclass ifNotNil: [ 			(method ast = (overridedSuperclass>>method selector) ast) 					ifTrue: [result addClass: aContext selectedClass selector: method selector ]]].! !!RBRepeteadMethodsInTheSuperclassRule methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 13:40'!name	^ 'Repeated method in the superclasses'! !!RBRepeteadMethodsInTheSuperclassRule methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 12:56'!rationale	^ 'If a class is overriding a method, it should use a different code. Is meaningless have a method in a class and in its superclass'! !!RBExplicitRequirementMethodsRule methodsFor: 'running' stamp: 'SebastianTleye 7/19/2013 11:10'!checkClass: aContext 	| selectedClass explicitRequirementMethods |	explicitRequirementMethods := Set new.	selectedClass := aContext selectedClass.		selectedClass traitComposition allSelectors do: [ :selector | | method |				method := selectedClass>>selector.				 (method isRequired and: [ method isSubclassResponsibility not ]) 						ifTrue: [ explicitRequirementMethods add: method ]].		explicitRequirementMethods do: [ :method |		aContext selectedClass withAllSuperclasses 			detect: [ :superclass | superclass canPerform: method selector ] ifNone: [result addClass: aContext selectedClass selector: method selector]].! !!RBExplicitRequirementMethodsRule methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 10:15'!name	^ 'Explicit requirement methods'! !!RBExplicitRequirementMethodsRule methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 10:13'!rationale	^ 'Classes that use traits with explicit requirement methods should either implement the method or inherit it.'! !!RBExplicitRequirementMethodsRule methodsFor: 'running' stamp: 'SebastianTleye 7/19/2013 11:10'!checkClass: aContext 	| selectedClass explicitRequirementMethods |	explicitRequirementMethods := Set new.	selectedClass := aContext selectedClass.		selectedClass traitComposition allSelectors do: [ :selector | | method |				method := selectedClass>>selector.				 (method isRequired and: [ method isSubclassResponsibility not ]) 						ifTrue: [ explicitRequirementMethods add: method ]].		explicitRequirementMethods do: [ :method |		aContext selectedClass withAllSuperclasses 			detect: [ :superclass | superclass canPerform: method selector ] ifNone: [result addClass: aContext selectedClass selector: method selector]].! !!RBExplicitRequirementMethodsRule methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 10:15'!name	^ 'Explicit requirement methods'! !!RBExplicitRequirementMethodsRule methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 10:13'!rationale	^ 'Classes that use traits with explicit requirement methods should either implement the method or inherit it.'! !!RBLocalMethodsOfAClassNotInItsTraitComposition methodsFor: 'running' stamp: 'SebastianTleye 7/19/2013 14:30'!checkClass: aContext 		"The comparison between methods is made using the ast, this is better than comparing source code only since it does not take into account identations, extra parenthesis, etc"		| selectedClass |	selectedClass := aContext selectedClass.	selectedClass hasTraitComposition ifTrue: [  		selectedClass localMethods do: [ :method | |traitCompositionMethod |			traitCompositionMethod := (selectedClass traitComposition methodDescriptionForSelector: method selector) effectiveMethod.			traitCompositionMethod ifNotNil: [								(traitCompositionMethod ast = method ast) 					ifTrue: [ result addClass: selectedClass selector: method selector ]]]].! !!RBLocalMethodsOfAClassNotInItsTraitComposition methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 13:40'!name	^ 'Repeated methods in the trait composition'! !!RBLocalMethodsOfAClassNotInItsTraitComposition methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 13:41'!rationale	^ 'If a class has a method in its trait composition, the method should not be implemented in the class'! !!RBLocalMethodsOfAClassNotInItsTraitComposition methodsFor: 'running' stamp: 'SebastianTleye 7/19/2013 14:30'!checkClass: aContext 		"The comparison between methods is made using the ast, this is better than comparing source code only since it does not take into account identations, extra parenthesis, etc"		| selectedClass |	selectedClass := aContext selectedClass.	selectedClass hasTraitComposition ifTrue: [  		selectedClass localMethods do: [ :method | |traitCompositionMethod |			traitCompositionMethod := (selectedClass traitComposition methodDescriptionForSelector: method selector) effectiveMethod.			traitCompositionMethod ifNotNil: [								(traitCompositionMethod ast = method ast) 					ifTrue: [ result addClass: selectedClass selector: method selector ]]]].! !!RBLocalMethodsOfAClassNotInItsTraitComposition methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 13:40'!name	^ 'Repeated methods in the trait composition'! !!RBLocalMethodsOfAClassNotInItsTraitComposition methodsFor: 'accessing' stamp: 'SebastianTleye 7/19/2013 13:41'!rationale	^ 'If a class has a method in its trait composition, the method should not be implemented in the class'! !        RBRefactoryTestDataApp removeSelector: #isLiteral!RBSmalllintTestObject removeSelector: #isLiteral!RxsCharacter removeSelector: #isNullable!RxsPredicate removeSelector: #isAtomic!RGVariableDefinition removeSelector: #isGlobalVariable!RGObject removeSelector: #isTrait!RPackageMCSynchronisationTest removeSelector: #allManagers!SHRBTextStyler removeSelector: #addAttributesFrom:satisfying:to:!SHRBTextStyler removeSelector: #attributesFor:!SHRBTextStyler removeSelector: #pixelHeight!SHRBTextStyler removeSelector: #privateFormat:!SHRBTextStyler removeSelector: #unstyledTextFrom:!!TApplyingOnClassSide methodsFor: 'pool variables' stamp: 'SebastianTleye 7/19/2013 18:32'!sharedPools	^OrderedCollection new.! !!TApplyingOnClassSide methodsFor: 'pool variables' stamp: 'SebastianTleye 7/19/2013 18:32'!sharedPools	^OrderedCollection new.! !!TraitComposition methodsFor: 'enquiries' stamp: 'SebastianTleye 7/19/2013 16:02'!allSelectors	^ Array streamContents: [ :stream | 		self transformations do: [ :transformation | stream nextPutAll: transformation allSelectors ]]! !!TraitComposition methodsFor: 'enquiries' stamp: 'SebastianTleye 7/19/2013 16:02'!allSelectors	^ Array streamContents: [ :stream | 		self transformations do: [ :transformation | stream nextPutAll: transformation allSelectors ]]! !Trait class removeSelector: #cleanUp!TraitDescription class removeSelector: #cleanUp!TClassDescription classTrait removeSelector: #canZapMethodDictionary!TClassDescription classTrait removeSelector: #cleanUp!TBehavior removeSelector: #classPool!TBehavior removeSelector: #sharedPools!TClass classTrait removeSelector: #canZapMethodDictionary!TClass classTrait removeSelector: #cleanUp!TClass removeSelector: #addSelector:withMethod:notifying:!TClass removeSelector: #addSelectorSilently:withMethod:!TClass removeSelector: #compile:notifying:!!MetacelloConfigurationBrowser methodsFor: 'initialize-release' stamp: 'TorstenBergmann 7/3/2013 20:58'!initialize	"Initialization code for MessageBrowser"	super initialize.	self windowIcon: self taskbarIcon.	 ! !!MetacelloConfigurationBrowser methodsFor: 'initialize-release' stamp: 'TorstenBergmann 7/3/2013 20:58'!initialize	"Initialization code for MessageBrowser"	super initialize.	self windowIcon: self taskbarIcon.	 ! !!FinderUI methodsFor: 'initialization' stamp: 'BenjaminVanRyseghem 2/21/2012 10:04'!initialize	"Initialization code for FinderUI"	super initialize.	finder := nil.	forceSearch := nil.	searchingTextArea := nil.	sourceTextArea := nil.	useRegExCheckbox := nil.	wrapBlockOrSelector := [: i | i asString ].! !!FinderUI methodsFor: 'initialization' stamp: 'BenjaminVanRyseghem 2/21/2012 10:04'!initialize	"Initialization code for FinderUI"	super initialize.	finder := nil.	forceSearch := nil.	searchingTextArea := nil.	sourceTextArea := nil.	useRegExCheckbox := nil.	wrapBlockOrSelector := [: i | i asString ].! !Inspector removeSelector: #theme!Inspector removeSelector: #trash!ClassCommentVersionsBrowser removeSelector: #wantsPrettyDiffOption!TimeProfiler removeSelector: #expandAllFromNode:!MetacelloConfigurationBrowser removeSelector: #title!SmalltalkEditor class removeSelector: #initialize!SmalltalkEditor removeSelector: #selectionPosition:!SmalltalkEditor removeSelector: #wordAtCaret!!ReleaseTest methodsFor: 'testing' stamp: 'SebastianTleye 7/19/2013 16:29'!testExplicitRequirementMethodsShouldBeImplementedInTheirUsers	"If a class is using a trait with an explicit requirement method, this class should implement the method"	| result |	result := RBExplicitRequirementMethodsRule new run.	self assert: result isEmpty.! !!ReleaseTest methodsFor: 'testing' stamp: 'SebastianTleye 7/19/2013 16:29'!testMethodsOfTheClassShouldNotBeRepeatedInItsSuperclasses	"If a class is using a trait with an explicit requirement method, this class should implement the method"	| result |	result := RBRepeteadMethodsInTheSuperclassRule new run.	self assert: result isEmpty.! !!ReleaseTest methodsFor: 'testing' stamp: 'SebastianTleye 7/19/2013 16:29'!testLocalMethodsOfTheClassShouldNotBeRepeatedInItsTraits	"If a class is using a trait with an explicit requirement method, this class should implement the method"	| result |	result := RBLocalMethodsOfAClassNotInItsTraitComposition new run.	self assert: result isEmpty.! !!ReleaseTest methodsFor: 'testing' stamp: 'SebastianTleye 7/19/2013 16:29'!testExplicitRequirementMethodsShouldBeImplementedInTheirUsers	"If a class is using a trait with an explicit requirement method, this class should implement the method"	| result |	result := RBExplicitRequirementMethodsRule new run.	self assert: result isEmpty.! !!ReleaseTest methodsFor: 'testing' stamp: 'SebastianTleye 7/19/2013 16:29'!testMethodsOfTheClassShouldNotBeRepeatedInItsSuperclasses	"If a class is using a trait with an explicit requirement method, this class should implement the method"	| result |	result := RBRepeteadMethodsInTheSuperclassRule new run.	self assert: result isEmpty.! !!ReleaseTest methodsFor: 'testing' stamp: 'SebastianTleye 7/19/2013 16:29'!testLocalMethodsOfTheClassShouldNotBeRepeatedInItsTraits	"If a class is using a trait with an explicit requirement method, this class should implement the method"	| result |	result := RBLocalMethodsOfAClassNotInItsTraitComposition new run.	self assert: result isEmpty.! !MCPackageTest removeSelector: #setUp!MCChangeNotificationTest removeSelector: #tearDown!