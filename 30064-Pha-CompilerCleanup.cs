'From Pharo3.0 of 18 March 2013 [Latest update: #30058] on 24 April 2013 at 4:41:29 pm'!Object subclass: #MethodAddition	instanceVariableNames: 'text category changeStamp requestor logSource myClass methodAndNode selector compiledMethod priorMethodOrNil priorCategoryOrNil '	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello-Loading'!!TraitDescription methodsFor: 'private' stamp: 'MarcusDenker 4/24/2013 16:24'!		logMethodSource2: aText forMethodWithNode: aCompiledMethod inCategory: category withStamp: changeStamp notifying: requestor 				aCompiledMethod					putSource: aText					class: self					category: category					withStamp: changeStamp 					inFile: 2					priorMethod: (self							compiledMethodAt: aCompiledMethod selector							ifAbsent: [])! !!ClassDescription methodsFor: 'private' stamp: 'MarcusDenker 4/24/2013 16:23'!		logMethodSource2: aText forMethodWithNode: aCompiledMethod inCategory: category withStamp: changeStamp notifying: requestor 				aCompiledMethod					putSource: aText					class: self					category: category					withStamp: changeStamp					inFile: 2					priorMethod: (self							compiledMethodAt: aCompiledMethod selector							ifAbsent: []) ! !!OCSourceCode2BytecodeTest methodsFor: 'compiling' stamp: 'MarcusDenker 4/24/2013 16:07'!		compile2methodNode: sourceStream 			"Compile code without logging the source in the changes file"			| methodNode |			methodNode := OpalCompiler new						from: sourceStream						class: self class						classified: nil						context: nil						notifying: nil;										translate: sourceStream						noPattern: false						ifFail: [^ nil].			^ methodNode generate: CompiledMethodTrailer empty! !!TPureBehavior methodsFor: '*Compiler-Kernel' stamp: 'MarcusDenker 4/24/2013 16:22'!		compile2: code classified: category notifying: requestor trailer: bytes ifFail: failBlock									"Compile code without logging the source in the changes file"									| methodNode |									methodNode  := self compilerClass new												compile: code												in: self												classified: category 												notifying: requestor												ifFail: failBlock.									^ methodNode generate: bytes! !!TClassAndTraitDescription methodsFor: 'compiling' stamp: 'ClementBera 4/24/2013 16:39'!compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource	| method |	method := self		compile2: text asString 		classified: category		notifying: requestor		trailer: self defaultMethodTrailer 		ifFail: [ ^ nil ].			logSource ifTrue: [		self 			logMethodSource2: text asString			forMethodWithNode: method			inCategory: category 			withStamp: changeStamp 			notifying: requestor ].			self 		addAndClassifySelector: method selector 		withMethod: method 		inProtocol: category 		notifying: requestor.				self instanceSide 		noteCompilationOf: method selector 		meta: self isClassSide.	^ method selector! !!TClassAndTraitDescription methodsFor: 'compiling' stamp: 'MarcusDenker 4/24/2013 16:15'!reformatMethodAt: selector	| newCodeString method |	newCodeString := self compilerClass 				format: (self sourceCodeAt: selector)				in: self				notifying: nil.	method := self compiledMethodAt: selector.	method 		putSource: newCodeString		class: self		category: (self organization categoryOfElement: selector)		inFile: 2		priorMethod: method! !!TPureBehavior methodsFor: '*Compiler-Kernel' stamp: 'ClementBera 4/24/2013 16:40'!compile: code notifying: requestor 	"Compile the argument, code, as source code in the context of the 	receiver and insEtall the result in the receiver's method dictionary. The 	second argument, requestor, is to be notified if an error occurs. The 	argument code is either a string or an object that converts to a string or 	a PositionableStream. This method also saves the source code."		| method |	method  := self		compile2: code "a Text"		classified: nil		notifying: requestor		trailer: self defaultMethodTrailer		ifFail: [^nil].	method putSource: code inFile: 2			withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Behavior method'; cr].	self addSelector: method selector withMethod: method notifying: requestor.	^ method selector! !!TPureBehavior methodsFor: 'traits' stamp: 'ClementBera 4/24/2013 16:39'!addTraitSelector: aSymbol withMethod: aCompiledMethod	"Add aMethod with selector aSymbol to my	methodDict. aMethod must not be defined locally."	| source method |	[(self includesLocalSelector: aSymbol) not] assert.	self ensureLocalSelectors.			source := aCompiledMethod getSourceReplacingSelectorWith: aSymbol.	method  := self		compile2: source		classified: aCompiledMethod category		notifying: nil		trailer: self defaultMethodTrailer		ifFail: [^nil].	method putSource: source inFile: 2		withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Trait method'; cr].				self basicAddSelector: aSymbol withMethod: method! !!TraitBehavior methodsFor: 'traits' stamp: 'ClementBera 4/24/2013 16:40'!addTraitSelector: aSymbol withMethod: aCompiledMethod	"Add aMethod with selector aSymbol to my	methodDict. aMethod must not be defined locally."	| source method |	[(self includesLocalSelector: aSymbol) not] assert.	self ensureLocalSelectors.			source := aCompiledMethod getSourceReplacingSelectorWith: aSymbol.	method  := self		compile2: source		classified: aCompiledMethod category		notifying: nil		trailer: self defaultMethodTrailer		ifFail: [^nil].	method putSource: source inFile: 2		withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Trait method'; cr].				self basicAddSelector: aSymbol withMethod: method	"self 		addAndClassifySelector: aSymbol 		withMethod: methodAndNode method 		inProtocol: aCompiledMethod category 		notifying: nil"! !!Behavior methodsFor: 'traits' stamp: 'MarcusDenker 4/24/2013 16:22'!addTraitSelector: aSymbol withMethod: aCompiledMethod	"Add aMethod with selector aSymbol to my	methodDict. aMethod must not be defined locally."	| source method |	[(self includesLocalSelector: aSymbol) not] assert.	self ensureLocalSelectors.			source := aCompiledMethod getSourceReplacingSelectorWith: aSymbol.	method  := self		compile2: source		classified: aCompiledMethod category		notifying: nil		trailer: self defaultMethodTrailer		ifFail: [^nil].	method putSource: source inFile: 2		withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Trait method'; cr].			method properties at: #traitSource put: aCompiledMethod.				self basicAddSelector: aSymbol withMethod: method! !!OCSourceCode2BytecodeTest methodsFor: 'tests' stamp: 'MarcusDenker 4/24/2013 16:06'!testDoDup	| selector methodNode scanner |	methodNode := self compile2methodNode: 'duplicateTopBytecode 3 + 4; yourself'.	selector := methodNode selector.	scanner := InstructionStream on: methodNode method.	1		timesRepeat: [scanner nextInstruction].	self assert: scanner peekInstruction selector == #doDup description: 'Failed ' , selector! !!CompiledMethod methodsFor: 'source code management' stamp: 'MarcusDenker 4/24/2013 16:15'!putSource: sourceStr class: class category: catName	inFile: fileIndex priorMethod: priorMethod	^ self putSource: sourceStr inFile: fileIndex withPreamble:			[:file | class printCategoryChunk: catName on: file priorMethod: priorMethod.			file cr]! !!CompiledMethod methodsFor: 'source code management' stamp: 'MarcusDenker 4/24/2013 16:15'!putSource: sourceStr class: class category: catName	withStamp: changeStamp inFile: fileIndex priorMethod: priorMethod	^ self putSource: sourceStr inFile: fileIndex withPreamble:			[:file |			class printCategoryChunk: catName on: file				withStamp: changeStamp priorMethod: priorMethod.			file cr]! !!CompiledMethod methodsFor: 'source code management' stamp: 'MarcusDenker 4/24/2013 16:12'!putSource: sourceStr inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	| file remoteString |	(SourceFiles == nil or: [(file := SourceFiles at: fileIndex) == nil]) ifTrue:		[^self becomeForward: (self copyWithSource: sourceStr)].	Smalltalk assureStartupStampLogged.	file setToEnd.	preambleBlock value: file.  "Write the preamble"	remoteString := RemoteString newString: sourceStr onFileNumber: fileIndex toFile: file.	file nextChunkPut: ' '.	InMidstOfFileinNotification signal ifFalse: [file flush].	self setSourcePosition: remoteString position inFile: fileIndex! !!MethodAddition methodsFor: 'operations' stamp: 'ClementBera 4/24/2013 16:38'!createCompiledMethod	compiledMethod := myClass compile2: text asString classified: category notifying: requestor							trailer: myClass defaultMethodTrailer ifFail: [^nil].	selector := compiledMethod selector.	self writeSourceToLog.	priorMethodOrNil := myClass compiledMethodAt: selector ifAbsent: [nil].	priorCategoryOrNil := myClass  organization categoryOfElement: selector.! !!MethodAddition methodsFor: 'operations' stamp: 'ClementBera 4/24/2013 16:38'!writeSourceToLog	logSource ifTrue: [		myClass logMethodSource2: text forMethodWithNode: compiledMethod			inCategory: category withStamp: changeStamp notifying: requestor.	].! !!CompiledMethodTest methodsFor: 'tests - comparing' stamp: 'ClementBera 4/24/2013 16:34'!testEqualityClassSideMethod   	| method1 method2 |	method1 := TestCase class			compile2: 'aMethod'			classified: nil			notifying: nil			trailer: CompiledMethodTrailer empty			ifFail: [^ nil].	method2 :=  TestCase class			compile2: 'aMethod'			classified: nil			notifying: nil			trailer: CompiledMethodTrailer empty			ifFail: [^ nil].	self deny: (method1 literalAt: method1 numLiterals) ==  (method2 literalAt: method2 numLiterals). 	self assert: method1 = method2.! !!CompiledMethodTest methodsFor: 'tests - comparing' stamp: 'ClementBera 4/24/2013 16:34'!testEqualityInstanceSideMethod   	| method1 method2 |	method1 :=  TestCase			compile2: 'aMethod'			classified: nil			notifying: nil			trailer: CompiledMethodTrailer empty			ifFail: [^ nil].	method2 :=  TestCase			compile2: 'aMethod'			classified: nil			notifying: nil			trailer: CompiledMethodTrailer empty			ifFail: [^ nil].	self assert: (method1 literalAt: method1 numLiterals) ==  (method2 literalAt: method2 numLiterals). 	self assert: method1 = method2.! !!TraitDescription methodsFor: 'compiling' stamp: 'ClementBera 4/24/2013 16:40'!compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource	| method |	method := self		compile2: text asString 		classified: category		notifying: requestor		trailer: self defaultMethodTrailer 		ifFail: [ ^ nil ].			logSource ifTrue: [		self 			logMethodSource2: text asString			forMethodWithNode: method			inCategory: category 			withStamp: changeStamp 			notifying: requestor ].			self 		addAndClassifySelector: method selector 		withMethod: method 		inProtocol: category 		notifying: requestor.				self instanceSide 		noteCompilationOf: method selector 		meta: self isClassSide.	^ method selector! !!TraitDescription methodsFor: 'private' stamp: 'MarcusDenker 4/24/2013 16:15'!logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor 	aCompiledMethodWithNode method		putSource: aText		class: self		category: category		withStamp: changeStamp 		inFile: 2		priorMethod: (self				compiledMethodAt: aCompiledMethodWithNode selector				ifAbsent: [])! !!ClassDescription methodsFor: 'compiling' stamp: 'MarcusDenker 4/24/2013 16:25'!compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource	| method |	method := self		compile2: text asString 		classified: category		notifying: requestor		trailer: self defaultMethodTrailer 		ifFail: [ ^ nil ].			logSource ifTrue: [		self 			logMethodSource2: text asString			forMethodWithNode: method			inCategory: category 			withStamp: changeStamp 			notifying: requestor ].			self 		addAndClassifySelector: method selector 		withMethod: method 		inProtocol: category 		notifying: requestor.				self instanceSide 		noteCompilationOf: method selector 		meta: self isClassSide.	^ method selector! !!ClassDescription methodsFor: 'compiling' stamp: 'MarcusDenker 4/24/2013 16:15'!reformatMethodAt: selector	| newCodeString method |	newCodeString := self compilerClass 				format: (self sourceCodeAt: selector)				in: self				notifying: nil.	method := self compiledMethodAt: selector.	method 		putSource: newCodeString		class: self		category: (self organization categoryOfElement: selector)		inFile: 2		priorMethod: method! !!ClassDescription methodsFor: 'private' stamp: 'MarcusDenker 4/24/2013 16:15'!logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor 	aCompiledMethodWithNode method		putSource: aText		class: self		category: category		withStamp: changeStamp		inFile: 2		priorMethod: (self				compiledMethodAt: aCompiledMethodWithNode selector				ifAbsent: []) ! !!ContextPart class methodsFor: 'simulation' stamp: 'MarcusDenker 4/24/2013 16:10'!initializeTryNamedPrimitiveTemplateMethod	| methodNode |	methodNode := Compiler new				compile: 'tryNamedPrimitive	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ ContextPart primitiveFailTokenFor: errorCode'				in: UndefinedObject				classified: nil				notifying: #()				ifFail: [ self error: 'method source is incorrect'. ].	TryNamedPrimitiveTemplateMethod := methodNode generate: CompiledMethodTrailer empty.	! !Object subclass: #MethodAddition	instanceVariableNames: 'text category changeStamp requestor logSource myClass selector compiledMethod priorMethodOrNil priorCategoryOrNil'	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello-Loading'!CompiledMethod removeSelector: #putSource:fromParseNode:class:category:inFile:priorMethod:!CompiledMethod removeSelector: #putSource:fromParseNode:class:category:withStamp:inFile:priorMethod:!CompiledMethod removeSelector: #putSource:fromParseNode:inFile:withPreamble:!!Behavior reorganize!('*Compiler-Kernel' binding compile2:classified:notifying:trailer:ifFail: compile: compile:classified:notifying:trailer:ifFail: compile:notifying: compileAll compilerClass decompile: decompilerClass defaultMethodTrailer evaluatorClass parserClass recompile: recompile:from: recompileChanges sourceCodeTemplate)('*Fuel' fuelIgnoredInstanceVariableNames fuelNew fuelNew:)('*Manifest-Core' isManifest)('*NativeBoost-Core' externalTypeAlias: nbBindingOf: nbFnArgument:generator:)('*Nautilus' realClass)('*NautilusCommon' addCategory:before:)('*Ring-Core-Kernel' methodNamed: methods methodsInProtocol: protocols)('*Rpackage-Core' originalName)('*System-Support' allCallsOn allCallsOn: allCallsOnIn: allUnsentMessages referencedClasses)('*Tools-Inspector' inspectAllInstances inspectSubInstances)('*ast-core' parseTreeFor:)('*opalcompiler-core' needsLongForm parseScope)('accessing' classDepth environment format isComposedBy: methodDict name numberOfInstanceVariables subclassDefinerClass typeOfClass)('accessing class hierarchy' allSubclasses allSubclassesWithLevelDo:startingLevel: allSuperclasses allSuperclassesIncluding: subclasses superclass superclass: withAllSubclasses withAllSuperclasses)('accessing instances and variables' allClassVarNames allInstVarNames allInstances allSharedPools allSubInstances allowsSubInstVars classVarNames includesSharedPoolNamed: instVarNames instanceCount sharedPools someInstance subclassInstVarNames)('accessing method dictionary' >> allMethods allSelectors allSelectorsAbove allSelectorsAboveUntil: allSelectorsBelow: allSelectorsWithout: basicLocalSelectors basicLocalSelectors: changeRecordsAt: classAndMethodFor:do:ifAbsent: commentsAt: commentsIn: compiledMethodAt: compiledMethodAt:ifAbsent: compress deregisterLocalSelector: firstCommentAt: firstPrecodeCommentFor: formalHeaderPartsFor: formalParametersAt: lookupSelector: methodDict: methodDictionary methodDictionary: methodHeaderFor: methodsDo: nextQuotePosIn:startingFrom: precodeCommentOrInheritedCommentFor: registerLocalSelector: selectors selectorsAndMethodsDo: selectorsDo: selectorsWithArgs: sourceCodeAt: sourceCodeAt:ifAbsent: standardMethodHeaderFor: supermostPrecodeCommentFor: ultimateSourceCodeAt:ifAbsent: zapAllMethods)('adding/removing methods' addSelector:withMethod: addSelector:withMethod:notifying: addSelectorSilently:withMethod: adoptInstance: basicAddSelector:withMethod: localSelectors methodDictAddSelectorSilently:withMethod: removeSelector: removeSelectorSilently:)('as yet unclassified' compiler)('cleanup' cleanUp cleanUp:)('compiling' compileAllFrom: instVarNamesAndOffsetsDo: variablesAndOffsetsDo:)('copying' copyOfMethodDictionary deepCopy postCopy)('enumerating' allInstancesDo: allSubInstancesDo: allSubclassesDo: allSuperclassesDo: allUnreferencedInstanceVariables selectSubclasses: selectSuperclasses: subclassesDo: withAllSubclassesDo: withAllSuperAndSubclassesDo: withAllSuperclassesDo:)('initialization' emptyMethodDictionary obsolete)('initialize-release' initialize nonObsoleteClass superclass:methodDictionary:format:)('instance creation' basicNew basicNew: new new:)('memory usage' instancesSizeInMemory)('obsolete subclasses' addObsoleteSubclass: allLocalCallsOn: obsoleteSubclasses removeAllObsoleteSubclasses removeObsoleteSubclass:)('printing' literalScannedAs:notifying: longPrintOn: printHierarchy printOn: printWithClosureAnalysisOn: storeLiteral:on:)('queries' copiedFromSuperclass: copiedMethodsFromSuperclass copiesFromSuperclass: copiesMethodsFromSuperclass whichClassDefinesClassVar: whichClassDefinesInstVar: whichSelectorsAssign: whichSelectorsRead: whichSuperclassSatisfies:)('system startup' shutDown shutDown: startUp startUp:)('testing' canZapMethodDictionary hasAbstractMethods instSize instSpec isAnonymous isBehavior isBits isBytes isCompact isFixed isMeta isObsolete isPointers isVariable isWeak isWords shouldNotBeRedefined sourceMatchesBytecodeAt:)('testing class hierarchy' includesBehavior: inheritsFrom: kindOfSubclass)('testing method dictionary' bindingOf: canPerform: canUnderstand: classBindingOf: hasMethods includesLocalSelector: includesSelector: isAliasSelector: isDisabledSelector: isLocalAliasSelector: thoroughHasSelectorReferringTo:special:byte: thoroughWhichSelectorsReferTo:special:byte: whichClassIncludesSelector: whichSelectorsAccess: whichSelectorsReferTo: whichSelectorsReferTo:special:byte: whichSelectorsStoreInto:)('traits' addExclusionOf:to: addToComposition: addTraitSelector:withMethod: applyChangesOfNewTraitCompositionReplacing: classesComposedWithMe ensureLocalSelectors flattenDown: flattenDownAllTraits hasTraitComposition noteChangedSelectors: notifyUsersOfChangedSelector: notifyUsersOfChangedSelectors: purgeLocalSelectors removeAlias:of: removeFromComposition: removeTraitSelector: setTraitComposition: setTraitCompositionFrom: traitComposition traitComposition: traitCompositionIncludes: traitCompositionString traitOrClassOfSelector: traitTransformations traits traitsProvidingSelector: updateMethodDictionarySelector:)('user interface' unreferencedInstanceVariables withAllSubAndSuperclassesDo:)('private' basicRemoveSelector: becomeCompact becomeCompactSimplyAt: becomeUncompact checkCanBeUncompact flushCache indexIfCompact setFormat: spaceUsed)!!TraitBehavior reorganize!('*Compiler-Kernel' binding bindingOf: compile2:classified:notifying:trailer:ifFail: compile: compile:classified:notifying:trailer:ifFail: compile:notifying: compileAll compileAllFrom: compilerClass decompile: decompilerClass defaultMethodTrailer evaluatorClass parserClass recompile: recompileChanges sourceCodeTemplate)('*Rpackage-Core' originalName)('*Tools-Browser' browse)('*opalcompiler-core' needsLongForm parseScope)('accessing class hierarchy' withAllSubclassesDo: withAllSuperclasses)('accessing method dictionary' >> addSelectorSilently:withMethod: allSelectors basicLocalSelectors basicLocalSelectors: changeRecordsAt: classAndMethodFor:do:ifAbsent: compiledMethodAt: compiledMethodAt:ifAbsent: compress deregisterLocalSelector: firstCommentAt: firstPrecodeCommentFor: formalHeaderPartsFor: formalParametersAt: lookupSelector: methodDict methodDict: methodDictionary methodDictionary: methodHeaderFor: methodsDo: precodeCommentOrInheritedCommentFor: registerLocalSelector: removeSelector: selectors selectorsAndMethodsDo: selectorsDo: selectorsWithArgs: sourceCodeAt: sourceCodeAt:ifAbsent: standardMethodHeaderFor: ultimateSourceCodeAt:ifAbsent: zapAllMethods)('adding/removing methods' addSelector:withMethod: addSelector:withMethod:notifying: basicAddSelector:withMethod: basicRemoveSelector: localSelectors methodDictAddSelectorSilently:withMethod: pureAddSelectorSilently:withMethod: pureRemoveSelector: removeSelectorSilently:)('as yet unclassified' addCategory:before: compiler methodNamed: methods methodsInProtocol: protocols)('class compatibility' allClassVarNames allInstVarNames allSubclasses allSubclassesDo: allSuperclasses allSuperclassesDo: classVarNames inheritsFrom: instSize instVarNames poolDictionaryNames subclassDefinerClass subclasses whichClassIncludesSelector: withAllSubclasses)('compiling' recompile:from:)('copying' copyOfMethodDictionary deepCopy postCopy)('initialization' emptyMethodDictionary obsolete)('initialize-release' initialize)('naming' environment name)('printing' literalScannedAs:notifying: longPrintOn: storeLiteral:on:)('remove me later' classPool sharedPools)('testing' canZapMethodDictionary includesBehavior: isComposedBy: isTrait)('testing method dictionary' canUnderstand: hasMethods includesLocalSelector: includesSelector: isAliasSelector: isDisabledSelector: isLocalAliasSelector: thoroughHasSelectorReferringTo:special:byte: thoroughWhichSelectorsReferTo:special:byte: whichSelectorsReferTo: whichSelectorsReferTo:special:byte:)('traits' addExclusionOf:to: addToComposition: addTraitSelector:withMethod: addUser: applyChangesOfNewTraitCompositionReplacing: classesComposedWithMe ensureLocalSelectors flattenDown: flattenDownAllTraits hasTraitComposition noteChangedSelectors: notifyUsersOfChangedSelector: notifyUsersOfChangedSelectors: purgeLocalSelectors removeAlias:of: removeFromComposition: removeFromTraitCompositionOfUsers removeTraitSelector: removeUser: setTraitComposition: setTraitCompositionFrom: traitComposition traitComposition: traitCompositionIncludes: traitCompositionString traitOrClassOfSelector: traitTransformations traits traitsProvidingSelector: updateMethodDictionarySelector: users)('private' spaceUsed)!