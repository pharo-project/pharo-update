'From PharoCore1.1ALPHA of ''19 October 2009'' [Latest update: #11081] on 8 December 2009 at 5:55:22 pm'!Smalltalk  removeClassNamed: #SharedQueue.Smalltalk renameClassNamed: #SharedQueue2 as: #SharedQueue!!HTTPLoader methodsFor: 'initialize/release' stamp: 'MarcusDenker 12/8/2009 17:53'!initialize	super initialize.	requests := SharedQueue new.	downloads := OrderedCollection new! !!HTTPLoader methodsFor: 'requests' stamp: 'MarcusDenker 12/8/2009 17:54'!abort	| oldRequests |	"Abort all requests"	oldRequests := requests.	requests := SharedQueue new. 	[oldRequests isEmpty] whileFalse: [		oldRequests next signalAbort].	downloads do: [:each | each ifNotNil: [each terminate]].	downloads := OrderedCollection new! !!InputEventSensor methodsFor: 'initialize-release' stamp: 'MarcusDenker 12/8/2009 17:55'!initialize	"Initialize the receiver"	super initialize.	eventQueue := SharedQueue new.	mouseButtons := 0.	mousePosition := 0 @ 0! !!SharedQueue2Test methodsFor: 'testing' stamp: 'MarcusDenker 12/8/2009 17:54'!testBasics	| q |	q := SharedQueue new.	self should: [ q nextOrNil = nil ].	q nextPut: 5.	self should: [ q nextOrNil = 5 ].	self should: [ q nextOrNil = nil ].! !!SharedQueue2Test methodsFor: 'testing' stamp: 'MarcusDenker 12/8/2009 17:54'!testContention1	"here is a test case that breaks the standard SharedQueue from Squeak 3.8"	| q r1 r2 |	q := SharedQueue new.	q nextPut: 5.	q nextPut: 10.	self should: [ q nextOrNil = 5 ].	[ r1 := q next ] fork.	[ r2 := q next ] fork.	Processor  yield.   "let the above two threads block"		q nextPut: 10.	Processor yield.	self should: [ r1 = 10 ].	self should: [ r2 = 10 ].	self should: [ q nextOrNil = nil ].! !!SharedQueue2Test methodsFor: 'testing' stamp: 'MarcusDenker 12/8/2009 17:54'!testNextOrNilSuchThat	| q item |	q := SharedQueue new.	q nextPut: 5.	q nextPut: 6.	item := q findFirst: [ :x | x even ].	self should: [ item = 6 ].	self should: [ q nextOrNil = 5 ].	self should: [ q nextOrNil = nil ].! !!Utilities class methodsFor: 'fetching updates' stamp: 'MarcusDenker 12/8/2009 17:54'!readServer: serverList special: indexPrefix updatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.""Utilities readServer: Utilities serverUrls updatesThrough: 828 saveLocally: true updateImage: true"	| urls failed loaded docQueue this nextDoc docQueueSema str updateName |	Cursor wait showWhile: [	urls := self newUpdatesOn: (serverList collect: [:url | url, 'updates/','pharo', ScriptLoader currentMajorVersionNumber asString, '/']) 				special: indexPrefix				throughNumber: maxNumber.	loaded := 0.	failed := nil.	"send downloaded documents throuh this queue"	docQueue := SharedQueue new.	"this semaphore keeps too many documents from beeing queueed up at a time"	docQueueSema := Semaphore new.	5 timesRepeat: [ docQueueSema signal ].	"fork a process to download the updates"	self retrieveUrls: urls ontoQueue: docQueue withWaitSema: docQueueSema.	"process downloaded updates in the foreground"	'Processing updates' displayProgressAt: Sensor cursorPoint from: 0 to: urls size during: [:bar |	[ this := docQueue next.	  nextDoc := docQueue next.  	  nextDoc = #failed ifTrue: [ failed := this ].	  (failed isNil and: [ nextDoc ~= #finished ])	] whileTrue: [		failed ifNil: [			nextDoc reset; text.			nextDoc size = 0 ifTrue: [ failed := this ]. ].		failed ifNil: [			nextDoc peek asciiValue = 4	"pure object file"				ifTrue: [failed := this]].	"Must be fileIn, not pure object file"		failed ifNil: [			"(this endsWith: '.html') ifTrue: [doc := doc asHtml]."				"HTML source code not supported here yet"			updateImage				ifTrue: [					updateName := (this findTokens: '/') last.					ChangeSet newChangesFromStream: nextDoc named: updateName.					SystemVersion current registerUpdate: updateName initialIntegerOrNil].			saveLocally ifTrue:				[self saveUpdate: nextDoc onFile: (this findTokens: '/') last].	"if wanted"			loaded := loaded + 1.			bar value: loaded].		docQueueSema signal].	]].	failed ~~ nil & (urls size - loaded > 0) ifTrue: [		str := loaded printString ,' new update file(s) processed.'.		str := str, '\Could not load ' withCRs, 			(urls size - loaded) printString ,' update file(s).',			'\Starting with "' withCRs, failed, '".'.		self inform: str].	^ Array with: failed with: loaded! !!WorldState class methodsFor: 'initialization' stamp: 'MarcusDenker 12/8/2009 17:55'!deferredUIMessages	^DeferredUIMessages ifNil: [DeferredUIMessages := SharedQueue new].! !!WorldState class methodsFor: 'initialization' stamp: 'MarcusDenker 12/8/2009 17:54'!initialize	"WorldState initialize"	MinCycleLapse := 20.		"allows 50 frames per second..."	DeferredUIMessages := SharedQueue new.! !WorldState initialize!